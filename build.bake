import file from WebSiteSupport.bake
import file from Deploy.bake
import file from Lib.bake
import file from Migration.bake
import file from Tools.bake
import file from db.bake
import System.Linq.Enumerable from System.Core
import System.IO

import Boo.Lang.PatternMatching
import Boo.Lang.Compiler
import Boo.Lang.Compiler.Pipelines
import Boo.Lang.Compiler.IO

import MySql.Data.MySqlClient from "lib/MySql.Data.dll"

import NHibernate.Tool.hbm2ddl from "lib/NHibernate.dll"
import NHibernate.AdoNet.Util
import NHibernate.Dialect
import NHibernate.Mapping
import NHibernate.Cfg

import Castle.Core from "lib/Castle/Castle.Core.dll"
import System.Collections.Generic
import System.Reflection
import Castle.ActiveRecord from "lib/Castle/Castle.ActiveRecord.dll"
import Castle.ActiveRecord.Framework
import Castle.ActiveRecord.Framework.Config
#import AdminInterface.Models from "src/AdminInterface/bin/AdminInterface.dll"


import log4net.Config from "lib/log4net.dll"
connectionString = "Data Source=sql.analit.net;Database=usersettings;User ID=Kvasov;Password=ghjgtkkth;Connect Timeout=300;pooling=true;convert zero datetime=yes;"

Global(
	project : "AdminInterface",
	deployTo : """\\acdcserv.adc.analit.net\WebApps\FutureAdm\""",
	humanReadableName : "Административный интерфейс (Новая реальность)"
)

assemblies = Dictionary[of string, Assembly]()

def Load(s as object, a as System.AssemblyLoadEventArgs ):
	assembly = a.LoadedAssembly
	assemblies[assembly.FullName] = assembly	

def Resolve(s as object, a as System.ResolveEventArgs):
	assembly as Assembly
	assemblies.TryGetValue(a.Name, assembly)
	return assembly

System.AppDomain.CurrentDomain.AssemblyLoad += Load
System.AppDomain.CurrentDomain.AssemblyResolve += Resolve

Task @Production:
	Configuration.evn = @production

Task @default, [@build]

Task @Build, [@buildWebSite]

Task @deploy, [@Production, @Build, @Migrate, @deployWebSite, @SendDeployNotification]

def GetConfiguration():
	config = InPlaceConfigurationSource()
	dict = Dictionary[of string, string]()
	dict.Add(Environment.Dialect, "NHibernate.Dialect.MySQLDialect")
	dict.Add(Environment.ConnectionDriver, "NHibernate.Driver.MySqlDataDriver")
	dict.Add(Environment.ConnectionProvider, "NHibernate.Connection.DriverConnectionProvider")
	dict.Add(Environment.ConnectionString, connectionString)
	dict.Add(Environment.ProxyFactoryFactoryClass, "NHibernate.ByteCode.Castle.ProxyFactoryFactory, NHibernate.ByteCode.Castle")
	dict.Add(Environment.Hbm2ddlKeyWords, "none")
	config.Add(ActiveRecordBase, dict)
	
	holder as ISessionFactoryHolder;
	ActiveRecordStarter.SessionFactoryHolderCreated += {h| holder = h}
	path = Path.GetFullPath("""src\AdminInterface\bin\AdminInterface.dll""")
	path1 = Path.GetFullPath("""src\AdminInterface\bin\Common.Web.Ui.dll""")
	#System.Environment.CurrentDirectory = Path.GetDirectoryName(path)
	ass = Assembly.LoadFrom(path)
	assemblies.Add("AdminInterface", ass)
	ass1 = Assembly.LoadFrom(path1)
	assemblies.Add("Common.Web.Ui", ass1)
	ActiveRecordStarter.Initialize(
		(ass, ass1), 
		config);
	return holder.GetAllConfigurations()[0]

def GetMigrationFileName(filename as string):
	return System.DateTime.Now.ToString("yyyyddMMhhmmss") + "_${filename}.sql"

def Save(filename as string, commands as string*):
	if not filename:
		System.Console.Write("enter file name:")
		filename = System.Console.ReadLine()
		
	if Exist("migrations"):
		MkDir("migrations")
	if filename:
		filename = filename.Trim()
		
	name = GetMigrationFileName(filename)
	migrationFile = Path.GetFullPath("migrations\\${name}")
	using stream = StreamWriter(File.OpenWrite(migrationFile)):
		for command in commands:
			stream.Write(command)
			stream.WriteLine(";")

	print "saved to ${migrationFile}"
	return migrationFile

task @SaveMigration:
	filename as string = Globals.SaveTo
	migration as string = Globals.MigrationCommand
	Save(filename, (migration, ))
	
def Apply(migrationFile as string):
	using connection = MySqlConnection(connectionString):
		connection.Open()
		command = MySqlCommand(File.ReadAllText(migrationFile), connection)
		command.ExecuteNonQuery()
		
task @MigrateBoo:
	GetConfiguration()
	booFile = Configuration.File
	booFile = Path.Combine("migrations", booFile + ".boo")
	compiler = BooCompiler()
	compiler.Parameters.Input.Add(FileInput(booFile))
	compiler.Parameters.Pipeline = CompileToMemory()
	result = compiler.Run()
	if len(result.Warnings):
		print(result.Warnings.ToString())
	if len(result.Errors):
		print(result.Errors.ToString(true))
		return
		
	main = result.GeneratedAssembly.EntryPoint
	if len(main.GetParameters()):
		main.Invoke(null, (null, ))
	else:
		main.Invoke(null, null)

Task @New:
	Save(null, ("", ))

Task @GenerateMigrations:
	configuration = GetConfiguration()
	mapping = configuration.BuildMapping()
	dialect = NHibernate.Dialect.Dialect.GetDialect(configuration.Properties)

	formatter = DdlFormatter()
	
	cfgProperties = Dictionary[of string, string](dialect.DefaultProperties)
	for pair in configuration.Properties:
		cfgProperties[pair.Key] = pair.Value
	connectionHelper = ManagedProviderConnectionHelper(cfgProperties)
	connectionHelper.Prepare()
	connection = connectionHelper.Connection

	commands = List[of string]()
	
#	using connection = MySqlConnection("Data Source=testsql.analit.net;Database=usersettings;User ID=system;Password=newpass;Connect Timeout=300;pooling=true;convert zero datetime=yes;"):
#		connection.Open()
	metadata = DatabaseMetadata(connection, dialect)
	for table as Table in cast(duck, configuration).TableMappings:
		if table.SchemaActions == SchemaAction.None or table.Schema == "logs":
			continue
		tableMetadata = metadata.GetTableMetadata(table.Name, table.Schema, table.Catalog, table.IsQuoted);
		tableMetadata = metadata.GetTableMetadata(table.Name, table.Schema, table.Catalog, table.IsQuoted);
		if tableMetadata:
			sqls = table.SqlAlterStrings(dialect, mapping, tableMetadata, null, null)
			for sql in sqls:
				commands.Add(sql)
				print formatter.Format(sql)
		else:
			sql = formatter.Format(table.SqlCreateString(dialect, mapping, null, null))
			commands.Add(sql)

	if not commands.Count:
		print "no changes find"
		return
	
	System.Console.Write("what should I do [s]ave migration or [a]ply and save?")
	match System.Console.ReadLine():
		case "a":
			Apply(Save(null, commands))
		case "s":
			Save(null, commands)
		otherwise:
			return

task @UpdateLogMigration:
	table = Configuration.Table
	Configuration.Host = "testsql.analit.net"
	Configuration.User = "system"
	Configuration.Password = "newpass"

	Globals.SaveTo = "${table}UpdateLog"
	Execute("UpdateLogTable")
	Execute("Prepare")
	Globals.SaveTo = "${table}DeleteTrigger"
	Execute("BuildDeleteTrigger")
	Globals.SaveTo = "${table}UpdateTrigger"
	Execute("BuildUpdateTrigger")
	Globals.SaveTo = "${table}InsertTrigger"
	Execute("BuildInsertTrigger")